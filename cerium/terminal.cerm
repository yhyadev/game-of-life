module game_of_life;

import "std/c.cerm";

type Generation = [170][170]u1;

const GENERATION_WIDTH = 170;
const GENERATION_HEIGHT = 170;

fn mod(a ssize, b ssize) ssize{ return ((a % b) + b) % b; }

fn generation_display(gen *Generation) {
    var y usize = 0;

    while y < GENERATION_HEIGHT {
        var x usize = 0;

        while x < GENERATION_WIDTH {
            if gen[y][x] == 1 {
                std::c::printf("●");
            } else {
                std::c::printf(" ");
            }

            x = x + 1;
        }

        std::c::printf("\n");

        y = y + 1;
    }
}

fn generation_random(gen *Generation) {
    var y usize = 0;

    while y < GENERATION_HEIGHT {
        var x usize = 0;

        while x < GENERATION_WIDTH {
            gen[y][x] = (std::c::rand() % 2) as u1;

            x = x + 1;
        }

        y = y + 1;
    }
}

fn generation_calculate_alive_neighbours(gen *Generation, ix usize, iy usize) u32 {
    var amount u32 = 0;

    var dy ssize = -1;
    
    while dy < 2 {
        var dx ssize = -1;

        while dx < 2 {
            if (dx == 0) & (dy == 0) {
                dx = dx + 1;

                continue;
            }

            var x = mod((ix as ssize + dx), GENERATION_WIDTH) as usize;
            var y = mod((iy as ssize + dy), GENERATION_HEIGHT) as usize;

            amount = amount + gen[y][x];

            dx = dx + 1;
        }

        dy = dy + 1;
    }

    return amount;
}

fn generation_update(gen *Generation) {
    var next_gen Generation;

    var y usize = 0;

    while y < GENERATION_HEIGHT {
        var x usize = 0;

        while x < GENERATION_WIDTH {
            var alive_neighbours = generation_calculate_alive_neighbours(gen, x, y);

            var current_cell = gen[y][x];

            var next_state = (((current_cell == 1) as u1 & ((alive_neighbours == 2) as u1 | (alive_neighbours == 3) as u1))
                            | ((current_cell == 0) as u1 & (alive_neighbours == 3) as u1));

            next_gen[y][x] = next_state;

            x = x + 1;
        }

        y = y + 1;
    }

    y = 0;

    while y < GENERATION_HEIGHT {
        var x usize = 0;

        while x < GENERATION_WIDTH {
            gen[y][x] = next_gen[y][x];

            x = x + 1;
        }

        y = y + 1;
    }
}

export fn main() u8 {
    var gen Generation;

    generation_random(&gen);

    while true {
        generation_display(&gen);
        generation_update(&gen);
    }

    return 0;
}
